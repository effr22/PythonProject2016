'''
Created on Oct 21, 2014

@author: Anshul
@author: David

This module processes a random input image and tries to find the closest image
it matches with against all the cropped design-seed images present in slices
folder.

It tries to find the closest design-seed image by comparing the code points
generated by the random image (code points are basically the k-means cluster
centroids which are in LAB color format) against all the training set that is
the code points for all the images which we have already computed and saved in
the "cluster.py" module. This comparison uses the Munkres algorithm to match code points
in these two sets, and calculate distance between two sets of clusters.
The design-seed image with the minimum distance
will be the closest match against our random image.

Below are the following dependencies which are required to be satisfied before
running this module:

1. Import the cluster module. Make sure that the "cluster.py" file is already
in the build path and has pre-computed code points. This means that one needs
to run cluster module first and generate the code points first before using
this module.
'''

from PIL import Image
import cluster
from munkres import Munkres
import os
import sys

FULL_PATH = "/usr/local/lib/python3.4/dist-packages/"
sys.path.append(FULL_PATH + "munkres3-1.0.5.5-py3.4.egg-info")
sys.path.append(FULL_PATH)

# sys.path.append("/usr/local/lib/python3.4/dist-packages/PIL/")
# sys.path.append("usr/lib/python3/dist-packages/numpy/core
#/multiarray.cpython-32mu.so")
# sys.path.append("usr/lib/python3/dist-packages/numpy/core/")

def create_distance_matrix(clusters1, clusters2):
    '''
    Calculates the distance between all points within clusters1
    and clusters2 and stores the result in a distance matrix.

    This function simply creates a distance matrix which uses the code points
    from the random image and the code points from the training set. It applies
    the euclidean distance on the LAB code code points and find the distance
    for each of the k x k elements and builds a matrix, which is simply a list
    of list. Here, k is the parameter k used in while applying the k-means
    algorithm.

    Args:
        clusters1: Code points in LAB format from the training set.
        clusters2: Code points in LAB format computed for random image.

    Returns:
        A list of list which is the distance matrix for each of the code points.
    '''
    distance_matrix = list()
    #print('Matching',clusters1[0], clusters2[0])
    for color_x in clusters1:
        row = list()
        for color_y in clusters2:
            row.append(cluster.euclidean_distance(color_x, color_y))
        distance_matrix.append(row)
    return distance_matrix


def calculate_distance(indices, cost_matrix):
    '''
    For all of the index pairs provided, enters the cost_matrix and
    adds all of the distances together.

    This function gets the bipartite indices as calculated by the Munkres
    algorithm; which are the (x, y) indices of the distance matrix, this is a
    tuple. These indices are applied on the cost matrix and the total is
    computed by supplying the indices as evaluated by the Munkres algorithm.
    A running total of the distance is returned.

    Args:
        indices: Tuples of (x, y) indexes computed by the Munkres algorithm.
        cost_matrix: A cost matrix which is simply a list of list that contains
                     distances for each code point of the random image to each
                     code point of the training image.

    Returns:
        running_total: An int value of the running total of the distances.
    '''
    running_total = 0
    for index_x, index_y in indices:
        running_total += cost_matrix[index_x][index_y]
    return running_total

#import warnings
def find_nearest_cluster(starting_filename):
    '''
    Takes the filename of an image, opens the image, deserializes the
    list of lists which contains a filename and its corresponding clusters,
    and clusters the test image.

    For each cluster in the training set, calculates the distance between
    the images by using Euclidean Distance on the nearest cluster color
    points between the two images and summing them all together.

    The result is the image in the training set that has the smallest
    distance from the test image.

    Args:
        starting_filename: An input random image.

    Returns:
        Closest image match from the training set.
    '''
    print('In find_nearest_cluster')
    # Obtain test image
    starting_img = Image.open(starting_filename)
    starting_img = starting_img.resize((150, 150))
    # Cluster test image
    #print('Here clustering')
    test_codes, labels = cluster.cluster_image(starting_img)
    print('Clustered test image')
    # warnings.filterwarnings('error')
    # print('Here')
    # try:
    #     test_codes = cluster.cluster_image(starting_img)
    #     print('Done clustering')
    # except Warning:
    #     print('Warning was raised as an exception!')
    # Obtain training clusters
    clusterfilename= "backend/clusterlistbytes.txt"
    training_clusters = cluster.deserialize(clusterfilename)
    #print('got DS clusters')
    current_distance = -1
    current_image = None
    current_image_clusters = []
    #print('Looking for match...')
    for filename, colors in training_clusters:
        # Get training image
        # For each training image, create a matrix of euclidian
        result = create_distance_matrix(test_codes, colors)
        mymunk = Munkres()
        try:
            bipartite_pairings = mymunk.compute(result)
            #print(filename)
            potential_distance = calculate_distance(bipartite_pairings, result)
            #print('potential_distance, current_distance', potential_distance, current_distance)
            if current_distance <0 or potential_distance < current_distance:
                current_distance = potential_distance
                current_image = filename
                current_image_clusters = colors
        except:
            print('Error in bipartite_pairings:', filename, colors)
        #print('new current_distance', current_distance)

    #print('Min distance:', current_distance)
    return current_image, test_codes, current_image_clusters, current_distance

#import warnings
def find_K_nearest_clusters(starting_filename, mindist=0, prevmatches=[]):
    '''
    Takes the filename of an image, opens the image, deserializes the
    list of lists which contains a filename and its corresponding clusters,
    and clusters the test image.

    For each cluster in the training set, calculates the distance between
    the images by using Euclidean Distance on the nearest cluster color
    points between the two images and summing them all together.

    The result is the image in the training set that has the smallest
    distance from the test image.

    Args:
        starting_filename: An input random image.

    Returns:
        Closest image match from the training set.
    '''
    print('In find_K_nearest_cluster')
    # Obtain test image
    starting_img = Image.open(starting_filename)
    starting_img = starting_img.resize((150, 150))
    # Cluster test image
    #print('Here clustering')
    test_codes = cluster.cluster_image(starting_img)
    print('Clustered test image')
    # warnings.filterwarnings('error')
    # print('Here')
    # try:
    #     test_codes = cluster.cluster_image(starting_img)
    #     print('Done clustering')
    # except Warning:
    #     print('Warning was raised as an exception!')
    # Obtain training clusters
    training_clusters = cluster.deserialize("backend/clusterlistbytes.txt")
    #print(training_clusters)
    #print('got DS clusters')
    current_distance = -1
    current_image = None
    current_image_clusters = []
    #print('Looking for match...')

    for filename, colors in training_clusters:
        if filename not in prevmatches:
            # Get training image
            # For each training image, create a matrix of euclidian
            potential_distance = matching.match_and_calculate_distance(test_codes, colors)
            #print(filename, potential_distance)
            #print('potential_distance, current_distance', potential_distance, current_distance)
            if (current_distance <0) or (potential_distance < current_distance and current_distance>mindist):
                current_distance = potential_distance
                current_image = filename
                current_image_clusters = colors

            #print('new current_distance', current_distance)

    print('Min distance:', current_distance, current_image)
    return current_image, test_codes, current_image_clusters, current_distance


def test_find_nearest_cluster(starting_filename):
    '''
    pass image from DS set - should match exactly that image
    '''
    print('In find_nearest_cluster')
    # Obtain test image
    starting_img = Image.open(starting_filename)
    starting_img = starting_img.resize((150, 150))

    # Obtain training clusters
    training_clusters = cluster.deserialize()

    # Cluster test image
    test_codes = cluster.cluster_image(starting_img)
    current_distance = -1
    current_image = None
    current_image_clusters = []
    print('len(training_clusters)',len(training_clusters))
    #print('Looking for match...')
    for filename, colors in training_clusters:
        print(filename)
        # Get training image
        # For each training image, create a matrix of euclidian
        potential_distance = matching.match_and_calculate_distance(test_codes, colors)
        #print('potential_distance, current_distance', potential_distance, current_distance)
        if current_distance <0 or potential_distance < current_distance:
            current_distance = potential_distance
            current_image = filename
            current_image_clusters = colors
        #print('new current_distance', current_distance)
    try:
        starting_img.close()
    except IOError:
        print('close() issue')
    #print('Min distance:', current_distance)
    print(current_image, test_codes, colors)
    return current_image, test_codes, colors

def test_find_nearest_cluster_with_C(starting_filename):
    '''
    pass image from DS set - should match exactly that image
    '''
    print('In find_nearest_cluster')
    # Obtain test image
    starting_img = Image.open(starting_filename)
    starting_img = starting_img.resize((150, 150))

    # Obtain training clusters
    training_clusters = cluster.deserialize()

    # Cluster test image
    test_codes = cluster.cluster_image(starting_img)
    
    current_distance = -1
    current_image = None
    current_image_clusters = []
    print('len(training_clusters)',len(training_clusters))
    #print('Looking for match...')
    for filename, colors in training_clusters:
        print(filename)
        # Get training image
        # For each training image, create a matrix of euclidian
        ##########################################
        #replace with C
        potential_distance = matching.match_and_calculate_distance(test_codes, colors)
        #print('potential_distance, current_distance', potential_distance, current_distance)
        if current_distance <0 or potential_distance < current_distance:
            current_distance = potential_distance
            current_image = filename
            current_image_clusters = colors
        #end replace with C
        ##########################################
    try:
        starting_img.close()
    except IOError:
        print('close() issue')
    #print('Min distance:', current_distance)
    print(current_image, test_codes, colors)
    return current_image, test_codes, colors


def test_training_set():
    '''
    Obtain file names from slices folder, check to see if it returns itself.
    '''
    for filename in os.listdir("slices"):
        resulting_filename = find_nearest_cluster("slices\\" + filename)
        assert filename == resulting_filename
        
import random
def get_random(K):
    clusterfilename= "backend/clusterlistbytesweighted.txt"
    training_clusters = cluster.deserialize(clusterfilename)
    sampl = random.sample(training_clusters, K)
    print(sampl)

if __name__ == "__main__":
    print('Started')
    # if len(sys.argv) != 2:
    #     print("Usage: nearest_palette.py path_to_user_image")
    #     sys.exit(1)
    # TEST_IMG_NAME = sys.argv[1]
    # print("Looking for closest to ", TEST_IMG_NAME)
    # CLOSEST_IMAGE = find_nearest_cluster(TEST_IMG_NAME)
    # print("File Name:", CLOSEST_IMAGE)
    
    #test_find_nearest_cluster('backend/DESIGNSEEDS/bloom_tones_1.jpg')

    # # Cluster test image
    # starting_img = Image.open('backend/DESIGNSEEDS/bloom_tones_1.jpg')
    # print('Here clustering')
    # test_codes = cluster.cluster_image(starting_img)
    # print('Here clustered')
    get_random(10)